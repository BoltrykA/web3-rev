{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { visit } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { getFragmentDefinitions } from \"../../utilities/index.js\";\n// As long as createFragmentRegistry is not imported or used, the\n// FragmentRegistry example implementation provided below should not be bundled\n// (by tree-shaking bundlers like Rollup), because the implementation of\n// InMemoryCache refers only to the TypeScript interface FragmentRegistryAPI,\n// never the concrete implementation FragmentRegistry (which is deliberately not\n// exported from this module).\nexport function createFragmentRegistry() {\n  var fragments = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    fragments[_i] = arguments[_i];\n  }\n  return new (FragmentRegistry.bind.apply(FragmentRegistry, __spreadArray([void 0], fragments, false)))();\n}\nvar FragmentRegistry = /** @class */function () {\n  // Call `createFragmentRegistry` instead of invoking the\n  // FragmentRegistry constructor directly. This reserves the constructor for\n  // future configuration of the FragmentRegistry.\n  function FragmentRegistry() {\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fragments[_i] = arguments[_i];\n    }\n    this.registry = Object.create(null);\n    this.resetCaches();\n    if (fragments.length) {\n      this.register.apply(this, fragments);\n    }\n  }\n  FragmentRegistry.prototype.register = function () {\n    var _this = this;\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fragments[_i] = arguments[_i];\n    }\n    var definitions = new Map();\n    fragments.forEach(function (doc) {\n      getFragmentDefinitions(doc).forEach(function (node) {\n        definitions.set(node.name.value, node);\n      });\n    });\n    definitions.forEach(function (node, name) {\n      if (node !== _this.registry[name]) {\n        _this.registry[name] = node;\n        _this.invalidate(name);\n      }\n    });\n    return this;\n  };\n  // Overridden in the resetCaches method below.\n  FragmentRegistry.prototype.invalidate = function (name) {};\n  FragmentRegistry.prototype.resetCaches = function () {\n    this.invalidate = (this.lookup = this.cacheUnaryMethod(this.lookup)).dirty; // This dirty function is bound to the wrapped lookup method.\n    this.transform = this.cacheUnaryMethod(this.transform);\n    this.findFragmentSpreads = this.cacheUnaryMethod(this.findFragmentSpreads);\n  };\n  FragmentRegistry.prototype.cacheUnaryMethod = function (originalMethod) {\n    return wrap(originalMethod.bind(this), {\n      makeCacheKey: function (arg) {\n        return arg;\n      }\n    });\n  };\n  FragmentRegistry.prototype.lookup = function (fragmentName) {\n    return this.registry[fragmentName] || null;\n  };\n  FragmentRegistry.prototype.transform = function (document) {\n    var _this = this;\n    var defined = new Map();\n    getFragmentDefinitions(document).forEach(function (def) {\n      defined.set(def.name.value, def);\n    });\n    var unbound = new Set();\n    var enqueue = function (spreadName) {\n      if (!defined.has(spreadName)) {\n        unbound.add(spreadName);\n      }\n    };\n    var enqueueChildSpreads = function (node) {\n      return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue);\n    };\n    enqueueChildSpreads(document);\n    var missing = [];\n    var map = Object.create(null);\n    // This Set forEach loop can be extended during iteration by adding\n    // additional strings to the unbound set.\n    unbound.forEach(function (fragmentName) {\n      var knownFragmentDef = defined.get(fragmentName);\n      if (knownFragmentDef) {\n        enqueueChildSpreads(map[fragmentName] = knownFragmentDef);\n      } else {\n        missing.push(fragmentName);\n        var def = _this.lookup(fragmentName);\n        if (def) {\n          enqueueChildSpreads(map[fragmentName] = def);\n        }\n      }\n    });\n    if (missing.length) {\n      var defsToAppend_1 = [];\n      missing.forEach(function (name) {\n        var def = map[name];\n        if (def) {\n          defsToAppend_1.push(def);\n        }\n      });\n      if (defsToAppend_1.length) {\n        document = __assign(__assign({}, document), {\n          definitions: document.definitions.concat(defsToAppend_1)\n        });\n      }\n    }\n    return document;\n  };\n  FragmentRegistry.prototype.findFragmentSpreads = function (root) {\n    var spreads = Object.create(null);\n    visit(root, {\n      FragmentSpread: function (node) {\n        spreads[node.name.value] = node;\n      }\n    });\n    return spreads;\n  };\n  return FragmentRegistry;\n}();","map":{"version":3,"names":["__assign","__spreadArray","visit","wrap","getFragmentDefinitions","createFragmentRegistry","fragments","_i","arguments","length","FragmentRegistry","bind","apply","registry","Object","create","resetCaches","register","prototype","_this","definitions","Map","forEach","doc","node","set","name","value","invalidate","lookup","cacheUnaryMethod","dirty","transform","findFragmentSpreads","originalMethod","makeCacheKey","arg","fragmentName","document","defined","def","unbound","Set","enqueue","spreadName","has","add","enqueueChildSpreads","keys","missing","map","knownFragmentDef","get","push","defsToAppend_1","concat","root","spreads","FragmentSpread"],"sources":["C:/Users/alici/Projets Web/web3-rev/exercises/mod8/library-frontend/node_modules/@apollo/client/cache/inmemory/fragmentRegistry.js"],"sourcesContent":["import { __assign, __spreadArray } from \"tslib\";\nimport { visit } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { getFragmentDefinitions } from \"../../utilities/index.js\";\n// As long as createFragmentRegistry is not imported or used, the\n// FragmentRegistry example implementation provided below should not be bundled\n// (by tree-shaking bundlers like Rollup), because the implementation of\n// InMemoryCache refers only to the TypeScript interface FragmentRegistryAPI,\n// never the concrete implementation FragmentRegistry (which is deliberately not\n// exported from this module).\nexport function createFragmentRegistry() {\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fragments[_i] = arguments[_i];\n    }\n    return new (FragmentRegistry.bind.apply(FragmentRegistry, __spreadArray([void 0], fragments, false)))();\n}\nvar FragmentRegistry = /** @class */ (function () {\n    // Call `createFragmentRegistry` instead of invoking the\n    // FragmentRegistry constructor directly. This reserves the constructor for\n    // future configuration of the FragmentRegistry.\n    function FragmentRegistry() {\n        var fragments = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fragments[_i] = arguments[_i];\n        }\n        this.registry = Object.create(null);\n        this.resetCaches();\n        if (fragments.length) {\n            this.register.apply(this, fragments);\n        }\n    }\n    FragmentRegistry.prototype.register = function () {\n        var _this = this;\n        var fragments = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fragments[_i] = arguments[_i];\n        }\n        var definitions = new Map();\n        fragments.forEach(function (doc) {\n            getFragmentDefinitions(doc).forEach(function (node) {\n                definitions.set(node.name.value, node);\n            });\n        });\n        definitions.forEach(function (node, name) {\n            if (node !== _this.registry[name]) {\n                _this.registry[name] = node;\n                _this.invalidate(name);\n            }\n        });\n        return this;\n    };\n    // Overridden in the resetCaches method below.\n    FragmentRegistry.prototype.invalidate = function (name) { };\n    FragmentRegistry.prototype.resetCaches = function () {\n        this.invalidate = (this.lookup = this.cacheUnaryMethod(this.lookup)).dirty; // This dirty function is bound to the wrapped lookup method.\n        this.transform = this.cacheUnaryMethod(this.transform);\n        this.findFragmentSpreads = this.cacheUnaryMethod(this.findFragmentSpreads);\n    };\n    FragmentRegistry.prototype.cacheUnaryMethod = function (originalMethod) {\n        return wrap(originalMethod.bind(this), {\n            makeCacheKey: function (arg) { return arg; },\n        });\n    };\n    FragmentRegistry.prototype.lookup = function (fragmentName) {\n        return this.registry[fragmentName] || null;\n    };\n    FragmentRegistry.prototype.transform = function (document) {\n        var _this = this;\n        var defined = new Map();\n        getFragmentDefinitions(document).forEach(function (def) {\n            defined.set(def.name.value, def);\n        });\n        var unbound = new Set();\n        var enqueue = function (spreadName) {\n            if (!defined.has(spreadName)) {\n                unbound.add(spreadName);\n            }\n        };\n        var enqueueChildSpreads = function (node) {\n            return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue);\n        };\n        enqueueChildSpreads(document);\n        var missing = [];\n        var map = Object.create(null);\n        // This Set forEach loop can be extended during iteration by adding\n        // additional strings to the unbound set.\n        unbound.forEach(function (fragmentName) {\n            var knownFragmentDef = defined.get(fragmentName);\n            if (knownFragmentDef) {\n                enqueueChildSpreads((map[fragmentName] = knownFragmentDef));\n            }\n            else {\n                missing.push(fragmentName);\n                var def = _this.lookup(fragmentName);\n                if (def) {\n                    enqueueChildSpreads((map[fragmentName] = def));\n                }\n            }\n        });\n        if (missing.length) {\n            var defsToAppend_1 = [];\n            missing.forEach(function (name) {\n                var def = map[name];\n                if (def) {\n                    defsToAppend_1.push(def);\n                }\n            });\n            if (defsToAppend_1.length) {\n                document = __assign(__assign({}, document), { definitions: document.definitions.concat(defsToAppend_1) });\n            }\n        }\n        return document;\n    };\n    FragmentRegistry.prototype.findFragmentSpreads = function (root) {\n        var spreads = Object.create(null);\n        visit(root, {\n            FragmentSpread: function (node) {\n                spreads[node.name.value] = node;\n            },\n        });\n        return spreads;\n    };\n    return FragmentRegistry;\n}());\n//# sourceMappingURL=fragmentRegistry.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}