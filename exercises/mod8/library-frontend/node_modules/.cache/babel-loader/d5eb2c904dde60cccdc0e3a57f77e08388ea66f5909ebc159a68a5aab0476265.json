{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport { reobserveCacheFirst } from \"./ObservableQuery.js\";\nimport { isNonEmptyArray, graphQLResultHasError, canUseWeakMap } from \"../utilities/index.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nvar destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();\nfunction wrapDestructiveCacheMethod(cache, methodName) {\n  var original = cache[methodName];\n  if (typeof original === \"function\") {\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(cache,\n      // The %1e15 allows the count to wrap around to 0 safely every\n      // quadrillion evictions, so there's no risk of overflow. To be\n      // clear, this is more of a pedantic principle than something\n      // that matters in any conceivable practical scenario.\n      (destructiveMethodCounts.get(cache) + 1) % 1e15);\n      // @ts-expect-error this is just too generic to be typed correctly\n      return original.apply(this, arguments);\n    };\n  }\n}\nfunction cancelNotifyTimeout(info) {\n  if (info[\"notifyTimeout\"]) {\n    clearTimeout(info[\"notifyTimeout\"]);\n    info[\"notifyTimeout\"] = void 0;\n  }\n}\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nvar QueryInfo = /** @class */function () {\n  function QueryInfo(queryManager, queryId) {\n    if (queryId === void 0) {\n      queryId = queryManager.generateQueryId();\n    }\n    this.queryId = queryId;\n    this.listeners = new Set();\n    this.document = null;\n    this.lastRequestId = 1;\n    this.stopped = false;\n    this.dirty = false;\n    this.observableQuery = null;\n    var cache = this.cache = queryManager.cache;\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n  QueryInfo.prototype.init = function (query) {\n    var networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n    }\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus: networkStatus\n    });\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n    return this;\n  };\n  QueryInfo.prototype.reset = function () {\n    cancelNotifyTimeout(this);\n    this.dirty = false;\n  };\n  QueryInfo.prototype.getDiff = function () {\n    var options = this.getDiffOptions();\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n    this.updateWatch(this.variables);\n    var oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return {\n        complete: false\n      };\n    }\n    var diff = this.cache.diff(options);\n    this.updateLastDiff(diff, options);\n    return diff;\n  };\n  QueryInfo.prototype.updateLastDiff = function (diff, options) {\n    this.lastDiff = diff ? {\n      diff: diff,\n      options: options || this.getDiffOptions()\n    } : void 0;\n  };\n  QueryInfo.prototype.getDiffOptions = function (variables) {\n    var _a;\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n    return {\n      query: this.document,\n      variables: variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults\n    };\n  };\n  QueryInfo.prototype.setDiff = function (diff) {\n    var _this = this;\n    var oldDiff = this.lastDiff && this.lastDiff.diff;\n    this.updateLastDiff(diff);\n    if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {\n      this.dirty = true;\n      if (!this.notifyTimeout) {\n        this.notifyTimeout = setTimeout(function () {\n          return _this.notify();\n        }, 0);\n      }\n    }\n  };\n  QueryInfo.prototype.setObservableQuery = function (oq) {\n    var _this = this;\n    if (oq === this.observableQuery) return;\n    if (this.oqListener) {\n      this.listeners.delete(this.oqListener);\n    }\n    this.observableQuery = oq;\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n      this.listeners.add(this.oqListener = function () {\n        var diff = _this.getDiff();\n        if (diff.fromOptimisticTransaction) {\n          // If this diff came from an optimistic transaction, deliver the\n          // current cache data to the ObservableQuery, but don't perform a\n          // reobservation, since oq.reobserveCacheFirst might make a network\n          // request, and we never want to trigger network requests in the\n          // middle of optimistic updates.\n          oq[\"observe\"]();\n        } else {\n          // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n          // using a temporary fetch policy of \"cache-first\", so complete cache\n          // results have a chance to be delivered without triggering additional\n          // network requests, even when options.fetchPolicy is \"network-only\"\n          // or \"cache-and-network\". All other fetch policies are preserved by\n          // this method, and are handled by calling oq.reobserve(). If this\n          // reobservation is spurious, isDifferentFromLastResult still has a\n          // chance to catch it before delivery to ObservableQuery subscribers.\n          reobserveCacheFirst(oq);\n        }\n      });\n    } else {\n      delete this.oqListener;\n    }\n  };\n  QueryInfo.prototype.notify = function () {\n    var _this = this;\n    cancelNotifyTimeout(this);\n    if (this.shouldNotify()) {\n      this.listeners.forEach(function (listener) {\n        return listener(_this);\n      });\n    }\n    this.dirty = false;\n  };\n  QueryInfo.prototype.shouldNotify = function () {\n    if (!this.dirty || !this.listeners.size) {\n      return false;\n    }\n    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {\n      var fetchPolicy = this.observableQuery.options.fetchPolicy;\n      if (fetchPolicy !== \"cache-only\" && fetchPolicy !== \"cache-and-network\") {\n        return false;\n      }\n    }\n    return true;\n  };\n  QueryInfo.prototype.stop = function () {\n    if (!this.stopped) {\n      this.stopped = true;\n      // Cancel the pending notify timeout\n      this.reset();\n      this.cancel();\n      // Revert back to the no-op version of cancel inherited from\n      // QueryInfo.prototype.\n      this.cancel = QueryInfo.prototype.cancel;\n      var oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  };\n  // This method is a no-op by default, until/unless overridden by the\n  // updateWatch method.\n  QueryInfo.prototype.cancel = function () {};\n  QueryInfo.prototype.updateWatch = function (variables) {\n    var _this = this;\n    if (variables === void 0) {\n      variables = this.variables;\n    }\n    var oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n    var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), {\n      watcher: this,\n      callback: function (diff) {\n        return _this.setDiff(diff);\n      }\n    });\n    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancel = this.cache.watch(this.lastWatch = watchOptions);\n    }\n  };\n  QueryInfo.prototype.resetLastWrite = function () {\n    this.lastWrite = void 0;\n  };\n  QueryInfo.prototype.shouldWrite = function (result, variables) {\n    var lastWrite = this.lastWrite;\n    return !(lastWrite &&\n    // If cache.evict has been called since the last time we wrote this\n    // data into the cache, there's a chance writing this result into\n    // the cache will repair what was evicted.\n    lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));\n  };\n  QueryInfo.prototype.markResult = function (result, document, options, cacheWriteBehavior) {\n    var _this = this;\n    var merger = new DeepMerger();\n    var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.reset();\n    if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n      var mergedData = mergeIncrementalData(this.getDiff().result, result);\n      result.data = mergedData;\n      // Detect the first chunk of a deferred query and merge it with existing\n      // cache data. This ensures a `cache-first` fetch policy that returns\n      // partial cache data or a `cache-and-network` fetch policy that already\n      // has full data in the cache does not complain when trying to merge the\n      // initial deferred server data with existing cache data.\n    } else if (\"hasNext\" in result && result.hasNext) {\n      var diff = this.getDiff();\n      result.data = merger.merge(diff.result, result.data);\n    }\n    this.graphQLErrors = graphQLErrors;\n    if (options.fetchPolicy === \"no-cache\") {\n      this.updateLastDiff({\n        result: result.data,\n        complete: true\n      }, this.getDiffOptions(options.variables));\n    } else if (cacheWriteBehavior !== 0 /* CacheWriteBehavior.FORBID */) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction(function (cache) {\n          if (_this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === 1 /* CacheWriteBehavior.OVERWRITE */\n            });\n\n            _this.lastWrite = {\n              result: result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(_this.cache)\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (_this.lastDiff && _this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = _this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n\n          var diffOptions = _this.getDiffOptions(options.variables);\n          var diff = cache.diff(diffOptions);\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called. We also avoid updating\n          // the watch if we are writing a result that doesn't match the current\n          // variables to avoid race conditions from broadcasting the wrong\n          // result.\n          if (!_this.stopped && equal(_this.variables, options.variables)) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            _this.updateWatch(options.variables);\n          }\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          _this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  };\n  QueryInfo.prototype.markReady = function () {\n    this.networkError = null;\n    return this.networkStatus = NetworkStatus.ready;\n  };\n  QueryInfo.prototype.markError = function (error) {\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n    this.reset();\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n    return error;\n  };\n  return QueryInfo;\n}();\nexport { QueryInfo };\nexport function shouldWriteResult(result, errorPolicy) {\n  if (errorPolicy === void 0) {\n    errorPolicy = \"none\";\n  }\n  var ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  var writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}","map":{"version":3,"names":["__assign","equal","DeepMerger","mergeIncrementalData","reobserveCacheFirst","isNonEmptyArray","graphQLResultHasError","canUseWeakMap","NetworkStatus","isNetworkRequestInFlight","destructiveMethodCounts","WeakMap","Map","wrapDestructiveCacheMethod","cache","methodName","original","set","get","apply","arguments","cancelNotifyTimeout","info","clearTimeout","QueryInfo","queryManager","queryId","generateQueryId","listeners","Set","document","lastRequestId","stopped","dirty","observableQuery","has","prototype","init","query","networkStatus","loading","variables","setVariables","lastDiff","Object","assign","networkError","graphQLErrors","setObservableQuery","reset","getDiff","options","getDiffOptions","diff","updateWatch","oq","fetchPolicy","complete","updateLastDiff","_a","returnPartialData","optimistic","canonizeResults","setDiff","_this","oldDiff","result","notifyTimeout","setTimeout","notify","oqListener","delete","add","fromOptimisticTransaction","shouldNotify","forEach","listener","size","stop","cancel","stopPolling","watchOptions","watcher","callback","lastWatch","watch","resetLastWrite","lastWrite","shouldWrite","dmCount","data","markResult","cacheWriteBehavior","merger","errors","slice","incremental","mergedData","hasNext","merge","shouldWriteResult","errorPolicy","performTransaction","writeQuery","overwrite","diffOptions","markReady","ready","markError","error","ignoreErrors","writeWithErrors"],"sources":["C:/Users/alici/Projets Web/web3-rev/exercises/mod8/library-frontend/node_modules/@apollo/client/core/QueryInfo.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport { reobserveCacheFirst } from \"./ObservableQuery.js\";\nimport { isNonEmptyArray, graphQLResultHasError, canUseWeakMap, } from \"../utilities/index.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nvar destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();\nfunction wrapDestructiveCacheMethod(cache, methodName) {\n    var original = cache[methodName];\n    if (typeof original === \"function\") {\n        cache[methodName] = function () {\n            destructiveMethodCounts.set(cache, \n            // The %1e15 allows the count to wrap around to 0 safely every\n            // quadrillion evictions, so there's no risk of overflow. To be\n            // clear, this is more of a pedantic principle than something\n            // that matters in any conceivable practical scenario.\n            (destructiveMethodCounts.get(cache) + 1) % 1e15);\n            // @ts-expect-error this is just too generic to be typed correctly\n            return original.apply(this, arguments);\n        };\n    }\n}\nfunction cancelNotifyTimeout(info) {\n    if (info[\"notifyTimeout\"]) {\n        clearTimeout(info[\"notifyTimeout\"]);\n        info[\"notifyTimeout\"] = void 0;\n    }\n}\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nvar QueryInfo = /** @class */ (function () {\n    function QueryInfo(queryManager, queryId) {\n        if (queryId === void 0) { queryId = queryManager.generateQueryId(); }\n        this.queryId = queryId;\n        this.listeners = new Set();\n        this.document = null;\n        this.lastRequestId = 1;\n        this.stopped = false;\n        this.dirty = false;\n        this.observableQuery = null;\n        var cache = (this.cache = queryManager.cache);\n        // Track how often cache.evict is called, since we want eviction to\n        // override the feud-stopping logic in the markResult method, by\n        // causing shouldWrite to return true. Wrapping the cache.evict method\n        // is a bit of a hack, but it saves us from having to make eviction\n        // counting an official part of the ApolloCache API.\n        if (!destructiveMethodCounts.has(cache)) {\n            destructiveMethodCounts.set(cache, 0);\n            wrapDestructiveCacheMethod(cache, \"evict\");\n            wrapDestructiveCacheMethod(cache, \"modify\");\n            wrapDestructiveCacheMethod(cache, \"reset\");\n        }\n    }\n    QueryInfo.prototype.init = function (query) {\n        var networkStatus = query.networkStatus || NetworkStatus.loading;\n        if (this.variables &&\n            this.networkStatus !== NetworkStatus.loading &&\n            !equal(this.variables, query.variables)) {\n            networkStatus = NetworkStatus.setVariables;\n        }\n        if (!equal(query.variables, this.variables)) {\n            this.lastDiff = void 0;\n        }\n        Object.assign(this, {\n            document: query.document,\n            variables: query.variables,\n            networkError: null,\n            graphQLErrors: this.graphQLErrors || [],\n            networkStatus: networkStatus,\n        });\n        if (query.observableQuery) {\n            this.setObservableQuery(query.observableQuery);\n        }\n        if (query.lastRequestId) {\n            this.lastRequestId = query.lastRequestId;\n        }\n        return this;\n    };\n    QueryInfo.prototype.reset = function () {\n        cancelNotifyTimeout(this);\n        this.dirty = false;\n    };\n    QueryInfo.prototype.getDiff = function () {\n        var options = this.getDiffOptions();\n        if (this.lastDiff && equal(options, this.lastDiff.options)) {\n            return this.lastDiff.diff;\n        }\n        this.updateWatch(this.variables);\n        var oq = this.observableQuery;\n        if (oq && oq.options.fetchPolicy === \"no-cache\") {\n            return { complete: false };\n        }\n        var diff = this.cache.diff(options);\n        this.updateLastDiff(diff, options);\n        return diff;\n    };\n    QueryInfo.prototype.updateLastDiff = function (diff, options) {\n        this.lastDiff =\n            diff ?\n                {\n                    diff: diff,\n                    options: options || this.getDiffOptions(),\n                }\n                : void 0;\n    };\n    QueryInfo.prototype.getDiffOptions = function (variables) {\n        var _a;\n        if (variables === void 0) { variables = this.variables; }\n        return {\n            query: this.document,\n            variables: variables,\n            returnPartialData: true,\n            optimistic: true,\n            canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults,\n        };\n    };\n    QueryInfo.prototype.setDiff = function (diff) {\n        var _this = this;\n        var oldDiff = this.lastDiff && this.lastDiff.diff;\n        this.updateLastDiff(diff);\n        if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {\n            this.dirty = true;\n            if (!this.notifyTimeout) {\n                this.notifyTimeout = setTimeout(function () { return _this.notify(); }, 0);\n            }\n        }\n    };\n    QueryInfo.prototype.setObservableQuery = function (oq) {\n        var _this = this;\n        if (oq === this.observableQuery)\n            return;\n        if (this.oqListener) {\n            this.listeners.delete(this.oqListener);\n        }\n        this.observableQuery = oq;\n        if (oq) {\n            oq[\"queryInfo\"] = this;\n            this.listeners.add((this.oqListener = function () {\n                var diff = _this.getDiff();\n                if (diff.fromOptimisticTransaction) {\n                    // If this diff came from an optimistic transaction, deliver the\n                    // current cache data to the ObservableQuery, but don't perform a\n                    // reobservation, since oq.reobserveCacheFirst might make a network\n                    // request, and we never want to trigger network requests in the\n                    // middle of optimistic updates.\n                    oq[\"observe\"]();\n                }\n                else {\n                    // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n                    // using a temporary fetch policy of \"cache-first\", so complete cache\n                    // results have a chance to be delivered without triggering additional\n                    // network requests, even when options.fetchPolicy is \"network-only\"\n                    // or \"cache-and-network\". All other fetch policies are preserved by\n                    // this method, and are handled by calling oq.reobserve(). If this\n                    // reobservation is spurious, isDifferentFromLastResult still has a\n                    // chance to catch it before delivery to ObservableQuery subscribers.\n                    reobserveCacheFirst(oq);\n                }\n            }));\n        }\n        else {\n            delete this.oqListener;\n        }\n    };\n    QueryInfo.prototype.notify = function () {\n        var _this = this;\n        cancelNotifyTimeout(this);\n        if (this.shouldNotify()) {\n            this.listeners.forEach(function (listener) { return listener(_this); });\n        }\n        this.dirty = false;\n    };\n    QueryInfo.prototype.shouldNotify = function () {\n        if (!this.dirty || !this.listeners.size) {\n            return false;\n        }\n        if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {\n            var fetchPolicy = this.observableQuery.options.fetchPolicy;\n            if (fetchPolicy !== \"cache-only\" && fetchPolicy !== \"cache-and-network\") {\n                return false;\n            }\n        }\n        return true;\n    };\n    QueryInfo.prototype.stop = function () {\n        if (!this.stopped) {\n            this.stopped = true;\n            // Cancel the pending notify timeout\n            this.reset();\n            this.cancel();\n            // Revert back to the no-op version of cancel inherited from\n            // QueryInfo.prototype.\n            this.cancel = QueryInfo.prototype.cancel;\n            var oq = this.observableQuery;\n            if (oq)\n                oq.stopPolling();\n        }\n    };\n    // This method is a no-op by default, until/unless overridden by the\n    // updateWatch method.\n    QueryInfo.prototype.cancel = function () { };\n    QueryInfo.prototype.updateWatch = function (variables) {\n        var _this = this;\n        if (variables === void 0) { variables = this.variables; }\n        var oq = this.observableQuery;\n        if (oq && oq.options.fetchPolicy === \"no-cache\") {\n            return;\n        }\n        var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function (diff) { return _this.setDiff(diff); } });\n        if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n            this.cancel();\n            this.cancel = this.cache.watch((this.lastWatch = watchOptions));\n        }\n    };\n    QueryInfo.prototype.resetLastWrite = function () {\n        this.lastWrite = void 0;\n    };\n    QueryInfo.prototype.shouldWrite = function (result, variables) {\n        var lastWrite = this.lastWrite;\n        return !(lastWrite &&\n            // If cache.evict has been called since the last time we wrote this\n            // data into the cache, there's a chance writing this result into\n            // the cache will repair what was evicted.\n            lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n            equal(variables, lastWrite.variables) &&\n            equal(result.data, lastWrite.result.data));\n    };\n    QueryInfo.prototype.markResult = function (result, document, options, cacheWriteBehavior) {\n        var _this = this;\n        var merger = new DeepMerger();\n        var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];\n        // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n        // requests. To allow future notify timeouts, diff and dirty are reset as well.\n        this.reset();\n        if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n            var mergedData = mergeIncrementalData(this.getDiff().result, result);\n            result.data = mergedData;\n            // Detect the first chunk of a deferred query and merge it with existing\n            // cache data. This ensures a `cache-first` fetch policy that returns\n            // partial cache data or a `cache-and-network` fetch policy that already\n            // has full data in the cache does not complain when trying to merge the\n            // initial deferred server data with existing cache data.\n        }\n        else if (\"hasNext\" in result && result.hasNext) {\n            var diff = this.getDiff();\n            result.data = merger.merge(diff.result, result.data);\n        }\n        this.graphQLErrors = graphQLErrors;\n        if (options.fetchPolicy === \"no-cache\") {\n            this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));\n        }\n        else if (cacheWriteBehavior !== 0 /* CacheWriteBehavior.FORBID */) {\n            if (shouldWriteResult(result, options.errorPolicy)) {\n                // Using a transaction here so we have a chance to read the result\n                // back from the cache before the watch callback fires as a result\n                // of writeQuery, so we can store the new diff quietly and ignore\n                // it when we receive it redundantly from the watch callback.\n                this.cache.performTransaction(function (cache) {\n                    if (_this.shouldWrite(result, options.variables)) {\n                        cache.writeQuery({\n                            query: document,\n                            data: result.data,\n                            variables: options.variables,\n                            overwrite: cacheWriteBehavior === 1 /* CacheWriteBehavior.OVERWRITE */,\n                        });\n                        _this.lastWrite = {\n                            result: result,\n                            variables: options.variables,\n                            dmCount: destructiveMethodCounts.get(_this.cache),\n                        };\n                    }\n                    else {\n                        // If result is the same as the last result we received from\n                        // the network (and the variables match too), avoid writing\n                        // result into the cache again. The wisdom of skipping this\n                        // cache write is far from obvious, since any cache write\n                        // could be the one that puts the cache back into a desired\n                        // state, fixing corruption or missing data. However, if we\n                        // always write every network result into the cache, we enable\n                        // feuds between queries competing to update the same data in\n                        // incompatible ways, which can lead to an endless cycle of\n                        // cache broadcasts and useless network requests. As with any\n                        // feud, eventually one side must step back from the brink,\n                        // letting the other side(s) have the last word(s). There may\n                        // be other points where we could break this cycle, such as\n                        // silencing the broadcast for cache.writeQuery (not a good\n                        // idea, since it just delays the feud a bit) or somehow\n                        // avoiding the network request that just happened (also bad,\n                        // because the server could return useful new data). All\n                        // options considered, skipping this cache write seems to be\n                        // the least damaging place to break the cycle, because it\n                        // reflects the intuition that we recently wrote this exact\n                        // result into the cache, so the cache *should* already/still\n                        // contain this data. If some other query has clobbered that\n                        // data in the meantime, that's too bad, but there will be no\n                        // winners if every query blindly reverts to its own version\n                        // of the data. This approach also gives the network a chance\n                        // to return new data, which will be written into the cache as\n                        // usual, notifying only those queries that are directly\n                        // affected by the cache updates, as usual. In the future, an\n                        // even more sophisticated cache could perhaps prevent or\n                        // mitigate the clobbering somehow, but that would make this\n                        // particular cache write even less important, and thus\n                        // skipping it would be even safer than it is today.\n                        if (_this.lastDiff && _this.lastDiff.diff.complete) {\n                            // Reuse data from the last good (complete) diff that we\n                            // received, when possible.\n                            result.data = _this.lastDiff.diff.result;\n                            return;\n                        }\n                        // If the previous this.diff was incomplete, fall through to\n                        // re-reading the latest data with cache.diff, below.\n                    }\n                    var diffOptions = _this.getDiffOptions(options.variables);\n                    var diff = cache.diff(diffOptions);\n                    // In case the QueryManager stops this QueryInfo before its\n                    // results are delivered, it's important to avoid restarting the\n                    // cache watch when markResult is called. We also avoid updating\n                    // the watch if we are writing a result that doesn't match the current\n                    // variables to avoid race conditions from broadcasting the wrong\n                    // result.\n                    if (!_this.stopped && equal(_this.variables, options.variables)) {\n                        // Any time we're about to update this.diff, we need to make\n                        // sure we've started watching the cache.\n                        _this.updateWatch(options.variables);\n                    }\n                    // If we're allowed to write to the cache, and we can read a\n                    // complete result from the cache, update result.data to be the\n                    // result from the cache, rather than the raw network result.\n                    // Set without setDiff to avoid triggering a notify call, since\n                    // we have other ways of notifying for this result.\n                    _this.updateLastDiff(diff, diffOptions);\n                    if (diff.complete) {\n                        result.data = diff.result;\n                    }\n                });\n            }\n            else {\n                this.lastWrite = void 0;\n            }\n        }\n    };\n    QueryInfo.prototype.markReady = function () {\n        this.networkError = null;\n        return (this.networkStatus = NetworkStatus.ready);\n    };\n    QueryInfo.prototype.markError = function (error) {\n        this.networkStatus = NetworkStatus.error;\n        this.lastWrite = void 0;\n        this.reset();\n        if (error.graphQLErrors) {\n            this.graphQLErrors = error.graphQLErrors;\n        }\n        if (error.networkError) {\n            this.networkError = error.networkError;\n        }\n        return error;\n    };\n    return QueryInfo;\n}());\nexport { QueryInfo };\nexport function shouldWriteResult(result, errorPolicy) {\n    if (errorPolicy === void 0) { errorPolicy = \"none\"; }\n    var ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n    var writeWithErrors = !graphQLResultHasError(result);\n    if (!writeWithErrors && ignoreErrors && result.data) {\n        writeWithErrors = true;\n    }\n    return writeWithErrors;\n}\n//# sourceMappingURL=QueryInfo.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}